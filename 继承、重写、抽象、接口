1、继承
表示父类跟子类的关系，子类是父类的一种。
如果子类构造方法不指定super(...),则子类构造方法默认super()，会默认调用父类无参构造方法。调用构造方法，不是继承构造方法。
初始化顺寻为：父类属性→父类构造方法→子类属性→子类构造方法
public class extendTest extends father//使用extends表示继承，只能继承一个父类
{
    private int weight;
    public extendTest(String name, int age, int weight)
    {
        super(name,age);//在构造方法中使用super，会调用父类构造方法，必须写在第一行
        this.weight = weight;
    }
    public extendTest(){
        //this();不能同时使用this调用此类构造器方法，使用super调用父类构造器方法。
        super("qwe",132);//在子类构造器中，如果没有super(...)，则默认调用super()
    }
    //public extendTest(){}子类构造器默认调用super()，要求父类也有对应的无参构造器。
    public void print()
    {
        System.out.println("son");
        super.print();//在普通方法中使用super调用父类中的方法，super可在任意位置，不可与static同用
    }
    public static void main(String[] args) {
        extendTest ex = new extendTest();
        ex.print();
    }
}
class father
{
    private String name;
    private int age;

    public father(){}
    public father(String name, int age)
    {
        this.name = name;
        this.age = age;
    }
    public void prin()
    {
        System.out.println("father");
    }
    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }
    public int getAge() {
        return age;
    }
}
2、重写
子类重写父类方法，会优先调用子类方法。
重写的方法名称一样，形参列表一样，返回值一样或是子类。
重写方法不能缩小访问权限。
3、抽象
//1、有些类没有创建实例的意义，因此有了抽象类，抽象类不能实例化
//2、创建抽象类需要abstract关键字
//3、抽象类中可以有抽象方法和具体方法。子类必须实现父类的抽象方法。
abstract class AbstractT extends abs{
    final int i = 1;//final修饰的变量为常量，i的值无法更改就为1
    @Override
    public final void test1(){}//重写父类的实例方法，添加final修饰符，此方法无法被再次重写。
    
    public static void main(String[] args) {
        AbstractT a = new AbstractT() {//在创建子类实例的时候实现父类的抽象方法
            @Override
            void test() {
                System.out.println("123");
            }
        };
        a.test();
    }
}
abstract class abs
{
    abstract void test();//定义抽象方法，没有方法体
    public  void test1(){}
}

4、接口
1）接口使用implement实现，接口中所有方法都是抽象方法。接口可由具体类和抽象类实现，不能由接口实现。
2）默认是abstract修饰符，访问控制权限只能是public。不写就是public abstract 
3）接口不能被实例化。
4）实现类必须实现接口中所有的方法（包括抽象父类中未实现的方法）。抽象类可以实现接口，不用实现接口中的方法。
abstract  class A
{
    public abstract void m1();
    public abstract void m2();
}
interface In
{
    void in1();
    void in2();
}
abstract class B extends A implements In{//使用抽象类继承抽象类，实现接口
    @Override
    public void m1(){}//抽象类中可以有具体方法

    @Override
    public void in1(){}
}
class D extends B{//使用具体类继承抽象类，具体类必须实现父类中未实现的抽象方法
    @Override
    public void m2(){//实现抽象父类中未实现的方法
        //In n = new In();接口不能实例化。
        //A a = new A();抽象类不能实例化。

    }
    public void in2(){}//由于接口中的方法修饰符默认为public abstract，因此实现方法修饰符必须显式public
}
